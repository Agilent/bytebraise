use std::str::FromStr;
use bytebraise::ast::{Expression};

grammar;


// Define Expression as a choice between simple expressions and concatenation
pub Expression: Box<Expression> = {
    SimpleExpression,
    Concatenate,
}

// Define SimpleExpression to include Indirection, Expansion, and other non-concatenated forms
SimpleExpression: Box<Expression> = {
    Indirection,
    Expansion,
    PythonExpansion,
    // Potentially other non-concatenated expressions
}

// Redefine Concatenate to explicitly handle the concatenation
Concatenate: Box<Expression> = {
    SimpleExpression SimpleExpression => Box::new(Expression::Concatenate(vec![<>])),
    Concatenate SimpleExpression => Box::new(Expression::Concatenate(vec![<>])),
    // This setup assumes Concatenate handles multiple expressions explicitly
}

// Definitions for Indirection and Expansion remain the same
Indirection: Box<Expression> = {
    "${" <e:Expansion> "}" => Box::new(Expression::Indirection(e))
}

Expansion: Box<Expression> = {
    "${" <v:r"[a-zA-Z0-9\\-_+./~]+?"> "}" => Box::new(Expression::Expansion(String::from(v)))
}

PythonExpansion: Box<Expression> = {
    <p:r"\$\{@.+?\}"> => Box::new(Expression::PythonExpansion(String::from(p)))
}